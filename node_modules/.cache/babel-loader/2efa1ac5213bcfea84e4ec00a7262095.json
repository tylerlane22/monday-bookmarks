{"ast":null,"code":"'use strict';\n\nvar url = require('url');\n\nvar gitHosts = require('./git-host-info.js');\n\nvar GitHost = module.exports = require('./git-host.js');\n\nvar protocolToRepresentationMap = {\n  'git+ssh:': 'sshurl',\n  'git+https:': 'https',\n  'ssh:': 'sshurl',\n  'git:': 'git'\n};\n\nfunction protocolToRepresentation(protocol) {\n  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1);\n}\n\nvar authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n};\nvar cache = {};\n\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (typeof giturl !== 'string') return;\n  var key = giturl + JSON.stringify(opts || {});\n\n  if (!(key in cache)) {\n    cache[key] = fromUrl(giturl, opts);\n  }\n\n  return cache[key];\n};\n\nfunction fromUrl(giturl, opts) {\n  if (giturl == null || giturl === '') return;\n  var url = fixupUnqualifiedGist(isGitHubShorthand(giturl) ? 'github:' + giturl : giturl);\n  var parsed = parseGitUrl(url);\n  var shortcutMatch = url.match(new RegExp('^([^:]+):(?:(?:[^@:]+(?:[^@]+)?@)?([^/]*))[/](.+?)(?:[.]git)?($|#)'));\n  var matches = Object.keys(gitHosts).map(function (gitHostName) {\n    try {\n      var gitHostInfo = gitHosts[gitHostName];\n      var auth = null;\n\n      if (parsed.auth && authProtocols[parsed.protocol]) {\n        auth = parsed.auth;\n      }\n\n      var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null;\n      var user = null;\n      var project = null;\n      var defaultRepresentation = null;\n\n      if (shortcutMatch && shortcutMatch[1] === gitHostName) {\n        user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2]);\n        project = decodeURIComponent(shortcutMatch[3]);\n        defaultRepresentation = 'shortcut';\n      } else {\n        if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, '') !== gitHostInfo.domain) return;\n        if (!gitHostInfo.protocols_re.test(parsed.protocol)) return;\n        if (!parsed.path) return;\n        var pathmatch = gitHostInfo.pathmatch;\n        var matched = parsed.path.match(pathmatch);\n        if (!matched) return;\n        /* istanbul ignore else */\n\n        if (matched[1] !== null && matched[1] !== undefined) {\n          user = decodeURIComponent(matched[1].replace(/^:/, ''));\n        }\n\n        project = decodeURIComponent(matched[2]);\n        defaultRepresentation = protocolToRepresentation(parsed.protocol);\n      }\n\n      return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);\n    } catch (ex) {\n      /* istanbul ignore else */\n      if (ex instanceof URIError) {} else throw ex;\n    }\n  }).filter(function (gitHostInfo) {\n    return gitHostInfo;\n  });\n  if (matches.length !== 1) return;\n  return matches[0];\n}\n\nfunction isGitHubShorthand(arg) {\n  // Note: This does not fully test the git ref format.\n  // See https://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html\n  //\n  // The only way to do this properly would be to shell out to\n  // git-check-ref-format, and as this is a fast sync function,\n  // we don't want to do that.  Just let git fail if it turns\n  // out that the commit-ish is invalid.\n  // GH usernames cannot start with . or -\n  return /^[^:@%/\\s.-][^:@%/\\s]*[/][^:@\\s/%]+(?:#.*)?$/.test(arg);\n}\n\nfunction fixupUnqualifiedGist(giturl) {\n  // necessary for round-tripping gists\n  var parsed = url.parse(giturl);\n\n  if (parsed.protocol === 'gist:' && parsed.host && !parsed.path) {\n    return parsed.protocol + '/' + parsed.host;\n  } else {\n    return giturl;\n  }\n}\n\nfunction parseGitUrl(giturl) {\n  var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/);\n\n  if (!matched) {\n    var legacy = url.parse(giturl); // If we don't have url.URL, then sorry, this is just not fixable.\n    // This affects Node <= 6.12.\n\n    if (legacy.auth && typeof url.URL === 'function') {\n      // git urls can be in the form of scp-style/ssh-connect strings, like\n      // git+ssh://user@host.com:some/path, which the legacy url parser\n      // supports, but WhatWG url.URL class does not.  However, the legacy\n      // parser de-urlencodes the username and password, so something like\n      // https://user%3An%40me:p%40ss%3Aword@x.com/ becomes\n      // https://user:n@me:p@ss:word@x.com/ which is all kinds of wrong.\n      // Pull off just the auth and host, so we dont' get the confusing\n      // scp-style URL, then pass that to the WhatWG parser to get the\n      // auth properly escaped.\n      var authmatch = giturl.match(/[^@]+@[^:/]+/);\n      /* istanbul ignore else - this should be impossible */\n\n      if (authmatch) {\n        var whatwg = new url.URL(authmatch[0]);\n        legacy.auth = whatwg.username || '';\n        if (whatwg.password) legacy.auth += ':' + whatwg.password;\n      }\n    }\n\n    return legacy;\n  }\n\n  return {\n    protocol: 'git+ssh:',\n    slashes: true,\n    auth: matched[1],\n    host: matched[2],\n    port: null,\n    hostname: matched[2],\n    hash: matched[4],\n    search: null,\n    query: null,\n    pathname: '/' + matched[3],\n    path: '/' + matched[3],\n    href: 'git+ssh://' + matched[1] + '@' + matched[2] + '/' + matched[3] + (matched[4] || '')\n  };\n}","map":{"version":3,"sources":["/Users/tylerlane/Documents/MondayApps/bookmarks/quickstart-react/node_modules/hosted-git-info/index.js"],"names":["url","require","gitHosts","GitHost","module","exports","protocolToRepresentationMap","protocolToRepresentation","protocol","slice","authProtocols","cache","fromUrl","giturl","opts","key","JSON","stringify","fixupUnqualifiedGist","isGitHubShorthand","parsed","parseGitUrl","shortcutMatch","match","RegExp","matches","Object","keys","map","gitHostName","gitHostInfo","auth","committish","hash","decodeURIComponent","substr","user","project","defaultRepresentation","host","domain","replace","protocols_re","test","path","pathmatch","matched","undefined","ex","URIError","filter","length","arg","parse","legacy","URL","authmatch","whatwg","username","password","slashes","port","hostname","search","query","pathname","href"],"mappings":"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","sourcesContent":["'use strict'\nvar url = require('url')\nvar gitHosts = require('./git-host-info.js')\nvar GitHost = module.exports = require('./git-host.js')\n\nvar protocolToRepresentationMap = {\n  'git+ssh:': 'sshurl',\n  'git+https:': 'https',\n  'ssh:': 'sshurl',\n  'git:': 'git'\n}\n\nfunction protocolToRepresentation (protocol) {\n  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1)\n}\n\nvar authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n}\n\nvar cache = {}\n\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (typeof giturl !== 'string') return\n  var key = giturl + JSON.stringify(opts || {})\n\n  if (!(key in cache)) {\n    cache[key] = fromUrl(giturl, opts)\n  }\n\n  return cache[key]\n}\n\nfunction fromUrl (giturl, opts) {\n  if (giturl == null || giturl === '') return\n  var url = fixupUnqualifiedGist(\n    isGitHubShorthand(giturl) ? 'github:' + giturl : giturl\n  )\n  var parsed = parseGitUrl(url)\n  var shortcutMatch = url.match(new RegExp('^([^:]+):(?:(?:[^@:]+(?:[^@]+)?@)?([^/]*))[/](.+?)(?:[.]git)?($|#)'))\n  var matches = Object.keys(gitHosts).map(function (gitHostName) {\n    try {\n      var gitHostInfo = gitHosts[gitHostName]\n      var auth = null\n      if (parsed.auth && authProtocols[parsed.protocol]) {\n        auth = parsed.auth\n      }\n      var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null\n      var user = null\n      var project = null\n      var defaultRepresentation = null\n      if (shortcutMatch && shortcutMatch[1] === gitHostName) {\n        user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2])\n        project = decodeURIComponent(shortcutMatch[3])\n        defaultRepresentation = 'shortcut'\n      } else {\n        if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, '') !== gitHostInfo.domain) return\n        if (!gitHostInfo.protocols_re.test(parsed.protocol)) return\n        if (!parsed.path) return\n        var pathmatch = gitHostInfo.pathmatch\n        var matched = parsed.path.match(pathmatch)\n        if (!matched) return\n        /* istanbul ignore else */\n        if (matched[1] !== null && matched[1] !== undefined) {\n          user = decodeURIComponent(matched[1].replace(/^:/, ''))\n        }\n        project = decodeURIComponent(matched[2])\n        defaultRepresentation = protocolToRepresentation(parsed.protocol)\n      }\n      return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts)\n    } catch (ex) {\n      /* istanbul ignore else */\n      if (ex instanceof URIError) {\n      } else throw ex\n    }\n  }).filter(function (gitHostInfo) { return gitHostInfo })\n  if (matches.length !== 1) return\n  return matches[0]\n}\n\nfunction isGitHubShorthand (arg) {\n  // Note: This does not fully test the git ref format.\n  // See https://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html\n  //\n  // The only way to do this properly would be to shell out to\n  // git-check-ref-format, and as this is a fast sync function,\n  // we don't want to do that.  Just let git fail if it turns\n  // out that the commit-ish is invalid.\n  // GH usernames cannot start with . or -\n  return /^[^:@%/\\s.-][^:@%/\\s]*[/][^:@\\s/%]+(?:#.*)?$/.test(arg)\n}\n\nfunction fixupUnqualifiedGist (giturl) {\n  // necessary for round-tripping gists\n  var parsed = url.parse(giturl)\n  if (parsed.protocol === 'gist:' && parsed.host && !parsed.path) {\n    return parsed.protocol + '/' + parsed.host\n  } else {\n    return giturl\n  }\n}\n\nfunction parseGitUrl (giturl) {\n  var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/)\n  if (!matched) {\n    var legacy = url.parse(giturl)\n    // If we don't have url.URL, then sorry, this is just not fixable.\n    // This affects Node <= 6.12.\n    if (legacy.auth && typeof url.URL === 'function') {\n      // git urls can be in the form of scp-style/ssh-connect strings, like\n      // git+ssh://user@host.com:some/path, which the legacy url parser\n      // supports, but WhatWG url.URL class does not.  However, the legacy\n      // parser de-urlencodes the username and password, so something like\n      // https://user%3An%40me:p%40ss%3Aword@x.com/ becomes\n      // https://user:n@me:p@ss:word@x.com/ which is all kinds of wrong.\n      // Pull off just the auth and host, so we dont' get the confusing\n      // scp-style URL, then pass that to the WhatWG parser to get the\n      // auth properly escaped.\n      var authmatch = giturl.match(/[^@]+@[^:/]+/)\n      /* istanbul ignore else - this should be impossible */\n      if (authmatch) {\n        var whatwg = new url.URL(authmatch[0])\n        legacy.auth = whatwg.username || ''\n        if (whatwg.password) legacy.auth += ':' + whatwg.password\n      }\n    }\n    return legacy\n  }\n  return {\n    protocol: 'git+ssh:',\n    slashes: true,\n    auth: matched[1],\n    host: matched[2],\n    port: null,\n    hostname: matched[2],\n    hash: matched[4],\n    search: null,\n    query: null,\n    pathname: '/' + matched[3],\n    path: '/' + matched[3],\n    href: 'git+ssh://' + matched[1] + '@' + matched[2] +\n          '/' + matched[3] + (matched[4] || '')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}