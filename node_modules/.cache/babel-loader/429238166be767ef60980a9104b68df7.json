{"ast":null,"code":"const Rx = require('rxjs');\n\nconst {\n  defaultIfEmpty,\n  delay,\n  filter,\n  mapTo,\n  skip,\n  take,\n  takeWhile\n} = require('rxjs/operators');\n\nconst defaults = require('../defaults');\n\nmodule.exports = class RestartProcess {\n  constructor({\n    delay,\n    tries,\n    logger,\n    scheduler\n  }) {\n    this.delay = +delay || defaults.restartDelay;\n    this.tries = +tries || defaults.restartTries;\n    this.logger = logger;\n    this.scheduler = scheduler;\n  }\n\n  handle(commands) {\n    if (this.tries === 0) {\n      return commands;\n    }\n\n    commands.map(command => command.close.pipe(take(this.tries), takeWhile(code => code !== 0))).map((failure, index) => Rx.merge( // Delay the emission (so that the restarts happen on time),\n    // explicitly telling the subscriber that a restart is needed\n    failure.pipe(delay(this.delay, this.scheduler), mapTo(true)), // Skip the first N emissions (as these would be duplicates of the above),\n    // meaning it will be empty because of success, or failed all N times,\n    // and no more restarts should be attempted.\n    failure.pipe(skip(this.tries), defaultIfEmpty(false))).subscribe(restart => {\n      const command = commands[index];\n\n      if (restart) {\n        this.logger.logCommandEvent(`${command.command} restarted`, command);\n        command.start();\n      }\n    }));\n    return commands.map(command => {\n      const closeStream = command.close.pipe(filter((value, emission) => {\n        // We let all success codes pass, and failures only after restarting won't happen again\n        return value === 0 || emission >= this.tries;\n      }));\n      return new Proxy(command, {\n        get(target, prop) {\n          return prop === 'close' ? closeStream : target[prop];\n        }\n\n      });\n    });\n  }\n\n};","map":{"version":3,"sources":["/Users/tylerlane/Documents/MondayApps/bookmarks/quickstart-react/node_modules/concurrently/src/flow-control/restart-process.js"],"names":["Rx","require","defaultIfEmpty","delay","filter","mapTo","skip","take","takeWhile","defaults","module","exports","RestartProcess","constructor","tries","logger","scheduler","restartDelay","restartTries","handle","commands","map","command","close","pipe","code","failure","index","merge","subscribe","restart","logCommandEvent","start","closeStream","value","emission","Proxy","get","target","prop"],"mappings":"AAAA,MAAMA,EAAE,GAAGC,OAAO,CAAC,MAAD,CAAlB;;AACA,MAAM;AAAEC,EAAAA,cAAF;AAAkBC,EAAAA,KAAlB;AAAyBC,EAAAA,MAAzB;AAAiCC,EAAAA,KAAjC;AAAwCC,EAAAA,IAAxC;AAA8CC,EAAAA,IAA9C;AAAoDC,EAAAA;AAApD,IAAkEP,OAAO,CAAC,gBAAD,CAA/E;;AAEA,MAAMQ,QAAQ,GAAGR,OAAO,CAAC,aAAD,CAAxB;;AAEAS,MAAM,CAACC,OAAP,GAAiB,MAAMC,cAAN,CAAqB;AAClCC,EAAAA,WAAW,CAAC;AAAEV,IAAAA,KAAF;AAASW,IAAAA,KAAT;AAAgBC,IAAAA,MAAhB;AAAwBC,IAAAA;AAAxB,GAAD,EAAsC;AAC7C,SAAKb,KAAL,GAAa,CAACA,KAAD,IAAUM,QAAQ,CAACQ,YAAhC;AACA,SAAKH,KAAL,GAAa,CAACA,KAAD,IAAUL,QAAQ,CAACS,YAAhC;AACA,SAAKH,MAAL,GAAcA,MAAd;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACH;;AAEDG,EAAAA,MAAM,CAACC,QAAD,EAAW;AACb,QAAI,KAAKN,KAAL,KAAe,CAAnB,EAAsB;AAClB,aAAOM,QAAP;AACH;;AAEDA,IAAAA,QAAQ,CAACC,GAAT,CAAaC,OAAO,IAAIA,OAAO,CAACC,KAAR,CAAcC,IAAd,CACpBjB,IAAI,CAAC,KAAKO,KAAN,CADgB,EAEpBN,SAAS,CAACiB,IAAI,IAAIA,IAAI,KAAK,CAAlB,CAFW,CAAxB,EAGGJ,GAHH,CAGO,CAACK,OAAD,EAAUC,KAAV,KAAoB3B,EAAE,CAAC4B,KAAH,EACvB;AACA;AACAF,IAAAA,OAAO,CAACF,IAAR,CAAarB,KAAK,CAAC,KAAKA,KAAN,EAAa,KAAKa,SAAlB,CAAlB,EAAgDX,KAAK,CAAC,IAAD,CAArD,CAHuB,EAIvB;AACA;AACA;AACAqB,IAAAA,OAAO,CAACF,IAAR,CAAalB,IAAI,CAAC,KAAKQ,KAAN,CAAjB,EAA+BZ,cAAc,CAAC,KAAD,CAA7C,CAPuB,EAQzB2B,SARyB,CAQfC,OAAO,IAAI;AACnB,YAAMR,OAAO,GAAGF,QAAQ,CAACO,KAAD,CAAxB;;AACA,UAAIG,OAAJ,EAAa;AACT,aAAKf,MAAL,CAAYgB,eAAZ,CAA6B,GAAET,OAAO,CAACA,OAAQ,YAA/C,EAA4DA,OAA5D;AACAA,QAAAA,OAAO,CAACU,KAAR;AACH;AACJ,KAd0B,CAH3B;AAmBA,WAAOZ,QAAQ,CAACC,GAAT,CAAaC,OAAO,IAAI;AAC3B,YAAMW,WAAW,GAAGX,OAAO,CAACC,KAAR,CAAcC,IAAd,CAAmBpB,MAAM,CAAC,CAAC8B,KAAD,EAAQC,QAAR,KAAqB;AAC/D;AACA,eAAOD,KAAK,KAAK,CAAV,IAAeC,QAAQ,IAAI,KAAKrB,KAAvC;AACH,OAH4C,CAAzB,CAApB;AAKA,aAAO,IAAIsB,KAAJ,CAAUd,OAAV,EAAmB;AACtBe,QAAAA,GAAG,CAACC,MAAD,EAASC,IAAT,EAAe;AACd,iBAAOA,IAAI,KAAK,OAAT,GAAmBN,WAAnB,GAAiCK,MAAM,CAACC,IAAD,CAA9C;AACH;;AAHqB,OAAnB,CAAP;AAKH,KAXM,CAAP;AAYH;;AA5CiC,CAAtC","sourcesContent":["const Rx = require('rxjs');\nconst { defaultIfEmpty, delay, filter, mapTo, skip, take, takeWhile } = require('rxjs/operators');\n\nconst defaults = require('../defaults');\n\nmodule.exports = class RestartProcess {\n    constructor({ delay, tries, logger, scheduler }) {\n        this.delay = +delay || defaults.restartDelay;\n        this.tries = +tries || defaults.restartTries;\n        this.logger = logger;\n        this.scheduler = scheduler;\n    }\n\n    handle(commands) {\n        if (this.tries === 0) {\n            return commands;\n        }\n\n        commands.map(command => command.close.pipe(\n            take(this.tries),\n            takeWhile(code => code !== 0)\n        )).map((failure, index) => Rx.merge(\n            // Delay the emission (so that the restarts happen on time),\n            // explicitly telling the subscriber that a restart is needed\n            failure.pipe(delay(this.delay, this.scheduler), mapTo(true)),\n            // Skip the first N emissions (as these would be duplicates of the above),\n            // meaning it will be empty because of success, or failed all N times,\n            // and no more restarts should be attempted.\n            failure.pipe(skip(this.tries), defaultIfEmpty(false))\n        ).subscribe(restart => {\n            const command = commands[index];\n            if (restart) {\n                this.logger.logCommandEvent(`${command.command} restarted`, command);\n                command.start();\n            }\n        }));\n\n        return commands.map(command => {\n            const closeStream = command.close.pipe(filter((value, emission) => {\n                // We let all success codes pass, and failures only after restarting won't happen again\n                return value === 0 || emission >= this.tries;\n            }));\n\n            return new Proxy(command, {\n                get(target, prop) {\n                    return prop === 'close' ? closeStream : target[prop];\n                }\n            });\n        });\n    }\n};\n"]},"metadata":{},"sourceType":"script"}