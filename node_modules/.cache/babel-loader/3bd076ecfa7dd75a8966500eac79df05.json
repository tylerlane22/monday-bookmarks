{"ast":null,"code":"'use strict'; // The ABNF grammar in the spec is totally ambiguous.\n//\n// This parser follows the operator precedence defined in the\n// `Order of Precedence and Parentheses` section.\n\nmodule.exports = function (tokens) {\n  var index = 0;\n\n  function hasMore() {\n    return index < tokens.length;\n  }\n\n  function token() {\n    return hasMore() ? tokens[index] : null;\n  }\n\n  function next() {\n    if (!hasMore()) {\n      throw new Error();\n    }\n\n    index++;\n  }\n\n  function parseOperator(operator) {\n    var t = token();\n\n    if (t && t.type === 'OPERATOR' && operator === t.string) {\n      next();\n      return t.string;\n    }\n  }\n\n  function parseWith() {\n    if (parseOperator('WITH')) {\n      var t = token();\n\n      if (t && t.type === 'EXCEPTION') {\n        next();\n        return t.string;\n      }\n\n      throw new Error('Expected exception after `WITH`');\n    }\n  }\n\n  function parseLicenseRef() {\n    // TODO: Actually, everything is concatenated into one string\n    // for backward-compatibility but it could be better to return\n    // a nice structure.\n    var begin = index;\n    var string = '';\n    var t = token();\n\n    if (t.type === 'DOCUMENTREF') {\n      next();\n      string += 'DocumentRef-' + t.string + ':';\n\n      if (!parseOperator(':')) {\n        throw new Error('Expected `:` after `DocumentRef-...`');\n      }\n    }\n\n    t = token();\n\n    if (t.type === 'LICENSEREF') {\n      next();\n      string += 'LicenseRef-' + t.string;\n      return {\n        license: string\n      };\n    }\n\n    index = begin;\n  }\n\n  function parseLicense() {\n    var t = token();\n\n    if (t && t.type === 'LICENSE') {\n      next();\n      var node = {\n        license: t.string\n      };\n\n      if (parseOperator('+')) {\n        node.plus = true;\n      }\n\n      var exception = parseWith();\n\n      if (exception) {\n        node.exception = exception;\n      }\n\n      return node;\n    }\n  }\n\n  function parseParenthesizedExpression() {\n    var left = parseOperator('(');\n\n    if (!left) {\n      return;\n    }\n\n    var expr = parseExpression();\n\n    if (!parseOperator(')')) {\n      throw new Error('Expected `)`');\n    }\n\n    return expr;\n  }\n\n  function parseAtom() {\n    return parseParenthesizedExpression() || parseLicenseRef() || parseLicense();\n  }\n\n  function makeBinaryOpParser(operator, nextParser) {\n    return function parseBinaryOp() {\n      var left = nextParser();\n\n      if (!left) {\n        return;\n      }\n\n      if (!parseOperator(operator)) {\n        return left;\n      }\n\n      var right = parseBinaryOp();\n\n      if (!right) {\n        throw new Error('Expected expression');\n      }\n\n      return {\n        left: left,\n        conjunction: operator.toLowerCase(),\n        right: right\n      };\n    };\n  }\n\n  var parseAnd = makeBinaryOpParser('AND', parseAtom);\n  var parseExpression = makeBinaryOpParser('OR', parseAnd);\n  var node = parseExpression();\n\n  if (!node || hasMore()) {\n    throw new Error('Syntax error');\n  }\n\n  return node;\n};","map":{"version":3,"sources":["/Users/tylerlane/Documents/MondayApps/bookmarks/quickstart-react/node_modules/spdx-expression-parse/parse.js"],"names":["module","exports","tokens","index","hasMore","length","token","next","Error","parseOperator","operator","t","type","string","parseWith","parseLicenseRef","begin","license","parseLicense","node","plus","exception","parseParenthesizedExpression","left","expr","parseExpression","parseAtom","makeBinaryOpParser","nextParser","parseBinaryOp","right","conjunction","toLowerCase","parseAnd"],"mappings":"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","sourcesContent":["'use strict'\n\n// The ABNF grammar in the spec is totally ambiguous.\n//\n// This parser follows the operator precedence defined in the\n// `Order of Precedence and Parentheses` section.\n\nmodule.exports = function (tokens) {\n  var index = 0\n\n  function hasMore () {\n    return index < tokens.length\n  }\n\n  function token () {\n    return hasMore() ? tokens[index] : null\n  }\n\n  function next () {\n    if (!hasMore()) {\n      throw new Error()\n    }\n    index++\n  }\n\n  function parseOperator (operator) {\n    var t = token()\n    if (t && t.type === 'OPERATOR' && operator === t.string) {\n      next()\n      return t.string\n    }\n  }\n\n  function parseWith () {\n    if (parseOperator('WITH')) {\n      var t = token()\n      if (t && t.type === 'EXCEPTION') {\n        next()\n        return t.string\n      }\n      throw new Error('Expected exception after `WITH`')\n    }\n  }\n\n  function parseLicenseRef () {\n    // TODO: Actually, everything is concatenated into one string\n    // for backward-compatibility but it could be better to return\n    // a nice structure.\n    var begin = index\n    var string = ''\n    var t = token()\n    if (t.type === 'DOCUMENTREF') {\n      next()\n      string += 'DocumentRef-' + t.string + ':'\n      if (!parseOperator(':')) {\n        throw new Error('Expected `:` after `DocumentRef-...`')\n      }\n    }\n    t = token()\n    if (t.type === 'LICENSEREF') {\n      next()\n      string += 'LicenseRef-' + t.string\n      return { license: string }\n    }\n    index = begin\n  }\n\n  function parseLicense () {\n    var t = token()\n    if (t && t.type === 'LICENSE') {\n      next()\n      var node = { license: t.string }\n      if (parseOperator('+')) {\n        node.plus = true\n      }\n      var exception = parseWith()\n      if (exception) {\n        node.exception = exception\n      }\n      return node\n    }\n  }\n\n  function parseParenthesizedExpression () {\n    var left = parseOperator('(')\n    if (!left) {\n      return\n    }\n\n    var expr = parseExpression()\n\n    if (!parseOperator(')')) {\n      throw new Error('Expected `)`')\n    }\n\n    return expr\n  }\n\n  function parseAtom () {\n    return (\n      parseParenthesizedExpression() ||\n      parseLicenseRef() ||\n      parseLicense()\n    )\n  }\n\n  function makeBinaryOpParser (operator, nextParser) {\n    return function parseBinaryOp () {\n      var left = nextParser()\n      if (!left) {\n        return\n      }\n\n      if (!parseOperator(operator)) {\n        return left\n      }\n\n      var right = parseBinaryOp()\n      if (!right) {\n        throw new Error('Expected expression')\n      }\n      return {\n        left: left,\n        conjunction: operator.toLowerCase(),\n        right: right\n      }\n    }\n  }\n\n  var parseAnd = makeBinaryOpParser('AND', parseAtom)\n  var parseExpression = makeBinaryOpParser('OR', parseAnd)\n\n  var node = parseExpression()\n  if (!node || hasMore()) {\n    throw new Error('Syntax error')\n  }\n  return node\n}\n"]},"metadata":{},"sourceType":"script"}