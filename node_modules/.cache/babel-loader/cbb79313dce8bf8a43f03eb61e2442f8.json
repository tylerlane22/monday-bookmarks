{"ast":null,"code":"const assert = require('assert');\n\nconst _ = require('lodash');\n\nconst spawn = require('spawn-command');\n\nconst treeKill = require('tree-kill');\n\nconst StripQuotes = require('./command-parser/strip-quotes');\n\nconst ExpandNpmShortcut = require('./command-parser/expand-npm-shortcut');\n\nconst ExpandNpmWildcard = require('./command-parser/expand-npm-wildcard');\n\nconst CompletionListener = require('./completion-listener');\n\nconst getSpawnOpts = require('./get-spawn-opts');\n\nconst Command = require('./command');\n\nconst defaults = {\n  spawn,\n  kill: treeKill,\n  raw: false,\n  controllers: []\n};\n\nmodule.exports = (commands, options) => {\n  assert.ok(Array.isArray(commands), '[concurrently] commands should be an array');\n  assert.notStrictEqual(commands.length, 0, '[concurrently] no commands provided');\n  options = _.defaults(options, defaults);\n  const commandParsers = [new StripQuotes(), new ExpandNpmShortcut(), new ExpandNpmWildcard()];\n  commands = _(commands).map(mapToCommandInfo).flatMap(command => parseCommand(command, commandParsers)).map((command, index) => new Command(Object.assign({\n    index,\n    spawnOpts: getSpawnOpts({\n      raw: options.raw,\n      env: command.env\n    }),\n    killProcess: options.kill,\n    spawn: options.spawn\n  }, command))).value();\n  commands = options.controllers.reduce((prevCommands, controller) => controller.handle(prevCommands), commands);\n  const commandsLeft = commands.slice();\n  const maxProcesses = Math.max(1, Number(options.maxProcesses) || commandsLeft.length);\n\n  for (let i = 0; i < maxProcesses; i++) {\n    maybeRunMore(commandsLeft);\n  }\n\n  return new CompletionListener({\n    successCondition: options.successCondition\n  }).listen(commands);\n};\n\nfunction mapToCommandInfo(command) {\n  return {\n    command: command.command || command,\n    name: command.name || '',\n    prefixColor: command.prefixColor || '',\n    env: command.env || {}\n  };\n}\n\nfunction parseCommand(command, parsers) {\n  return parsers.reduce((commands, parser) => _.flatMap(commands, command => parser.parse(command)), _.castArray(command));\n}\n\nfunction maybeRunMore(commandsLeft) {\n  const command = commandsLeft.shift();\n\n  if (!command) {\n    return;\n  }\n\n  command.start();\n  command.close.subscribe(() => {\n    maybeRunMore(commandsLeft);\n  });\n}","map":{"version":3,"sources":["/Users/tylerlane/Documents/MondayApps/bookmarks/quickstart-react/node_modules/concurrently/src/concurrently.js"],"names":["assert","require","_","spawn","treeKill","StripQuotes","ExpandNpmShortcut","ExpandNpmWildcard","CompletionListener","getSpawnOpts","Command","defaults","kill","raw","controllers","module","exports","commands","options","ok","Array","isArray","notStrictEqual","length","commandParsers","map","mapToCommandInfo","flatMap","command","parseCommand","index","Object","assign","spawnOpts","env","killProcess","value","reduce","prevCommands","controller","handle","commandsLeft","slice","maxProcesses","Math","max","Number","i","maybeRunMore","successCondition","listen","name","prefixColor","parsers","parser","parse","castArray","shift","start","close","subscribe"],"mappings":"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","sourcesContent":["const assert = require('assert');\nconst _ = require('lodash');\nconst spawn = require('spawn-command');\nconst treeKill = require('tree-kill');\n\nconst StripQuotes = require('./command-parser/strip-quotes');\nconst ExpandNpmShortcut = require('./command-parser/expand-npm-shortcut');\nconst ExpandNpmWildcard = require('./command-parser/expand-npm-wildcard');\n\nconst CompletionListener = require('./completion-listener');\n\nconst getSpawnOpts = require('./get-spawn-opts');\nconst Command = require('./command');\n\nconst defaults = {\n    spawn,\n    kill: treeKill,\n    raw: false,\n    controllers: []\n};\n\nmodule.exports = (commands, options) => {\n    assert.ok(Array.isArray(commands), '[concurrently] commands should be an array');\n    assert.notStrictEqual(commands.length, 0, '[concurrently] no commands provided');\n\n    options = _.defaults(options, defaults);\n\n    const commandParsers = [\n        new StripQuotes(),\n        new ExpandNpmShortcut(),\n        new ExpandNpmWildcard()\n    ];\n\n    commands = _(commands)\n        .map(mapToCommandInfo)\n        .flatMap(command => parseCommand(command, commandParsers))\n        .map((command, index) => new Command(\n            Object.assign({\n                index,\n                spawnOpts: getSpawnOpts({ raw: options.raw, env: command.env }),\n                killProcess: options.kill,\n                spawn: options.spawn,\n            }, command)\n        ))\n        .value();\n\n    commands = options.controllers.reduce(\n        (prevCommands, controller) => controller.handle(prevCommands),\n        commands\n    );\n\n    const commandsLeft = commands.slice();\n    const maxProcesses = Math.max(1, Number(options.maxProcesses) || commandsLeft.length);\n    for (let i = 0; i < maxProcesses; i++) {\n        maybeRunMore(commandsLeft);\n    }\n\n    return new CompletionListener({ successCondition: options.successCondition }).listen(commands);\n};\n\nfunction mapToCommandInfo(command) {\n    return {\n        command: command.command || command,\n        name: command.name || '',\n        prefixColor: command.prefixColor || '',\n        env: command.env || {},\n    };\n}\n\nfunction parseCommand(command, parsers) {\n    return parsers.reduce(\n        (commands, parser) => _.flatMap(commands, command => parser.parse(command)),\n        _.castArray(command)\n    );\n}\n\nfunction maybeRunMore(commandsLeft) {\n    const command = commandsLeft.shift();\n    if (!command) {\n        return;\n    }\n\n    command.start();\n    command.close.subscribe(() => {\n        maybeRunMore(commandsLeft);\n    });\n}\n"]},"metadata":{},"sourceType":"script"}