{"ast":null,"code":"const chalk = require('chalk');\n\nconst _ = require('lodash');\n\nconst formatDate = require('date-fns/format');\n\nconst defaults = require('./defaults');\n\nmodule.exports = class Logger {\n  constructor({\n    outputStream,\n    prefixFormat,\n    prefixLength,\n    raw,\n    timestampFormat\n  }) {\n    this.raw = raw;\n    this.outputStream = outputStream;\n    this.prefixFormat = prefixFormat;\n    this.prefixLength = prefixLength || defaults.prefixLength;\n    this.timestampFormat = timestampFormat || defaults.timestampFormat;\n  }\n\n  shortenText(text) {\n    if (!text || text.length <= this.prefixLength) {\n      return text;\n    }\n\n    const ellipsis = '..';\n    const prefixLength = this.prefixLength - ellipsis.length;\n    const endLength = Math.floor(prefixLength / 2);\n    const beginningLength = prefixLength - endLength;\n    const beginnning = text.substring(0, beginningLength);\n    const end = text.substring(text.length - endLength, text.length);\n    return beginnning + ellipsis + end;\n  }\n\n  getPrefixesFor(command) {\n    return {\n      none: '',\n      pid: command.pid,\n      index: command.index,\n      name: command.name,\n      command: this.shortenText(command.command),\n      time: formatDate(Date.now(), this.timestampFormat)\n    };\n  }\n\n  getPrefix(command) {\n    const prefix = this.prefixFormat || (command.name ? 'name' : 'index');\n\n    if (prefix === 'none') {\n      return '';\n    }\n\n    const prefixes = this.getPrefixesFor(command);\n\n    if (Object.keys(prefixes).includes(prefix)) {\n      return `[${prefixes[prefix]}]`;\n    }\n\n    return _.reduce(prefixes, (prev, val, key) => {\n      const keyRegex = new RegExp(_.escapeRegExp(`{${key}}`), 'g');\n      return prev.replace(keyRegex, val);\n    }, prefix).trim();\n  }\n\n  colorText(command, text) {\n    const color = _.get(chalk, command.prefixColor, chalk.gray.dim);\n\n    return color(text);\n  }\n\n  logCommandEvent(text, command) {\n    if (this.raw) {\n      return;\n    }\n\n    this.logCommandText(chalk.gray.dim(text) + '\\n', command);\n  }\n\n  logCommandText(text, command) {\n    const prefix = this.colorText(command, this.getPrefix(command));\n    return this.log(prefix + (prefix ? ' ' : ''), text);\n  }\n\n  logGlobalEvent(text) {\n    if (this.raw) {\n      return;\n    }\n\n    this.log(chalk.gray.dim('-->') + ' ', chalk.gray.dim(text) + '\\n');\n  }\n\n  log(prefix, text) {\n    if (this.raw) {\n      return this.outputStream.write(text);\n    } // #70 - replace some ANSI code that would impact clearing lines\n\n\n    text = text.replace(/\\u2026/g, '...');\n    const lines = text.split('\\n').map((line, index, lines) => {\n      // First line will write prefix only if we finished the last write with a LF.\n      // Last line won't write prefix because it should be empty.\n      if (index === 0 || index === lines.length - 1) {\n        return line;\n      }\n\n      return prefix + line;\n    });\n\n    if (!this.lastChar || this.lastChar === '\\n') {\n      this.outputStream.write(prefix);\n    }\n\n    this.lastChar = text[text.length - 1];\n    this.outputStream.write(lines.join('\\n'));\n  }\n\n};","map":{"version":3,"sources":["/Users/tylerlane/Documents/MondayApps/bookmarks/quickstart-react/node_modules/concurrently/src/logger.js"],"names":["chalk","require","_","formatDate","defaults","module","exports","Logger","constructor","outputStream","prefixFormat","prefixLength","raw","timestampFormat","shortenText","text","length","ellipsis","endLength","Math","floor","beginningLength","beginnning","substring","end","getPrefixesFor","command","none","pid","index","name","time","Date","now","getPrefix","prefix","prefixes","Object","keys","includes","reduce","prev","val","key","keyRegex","RegExp","escapeRegExp","replace","trim","colorText","color","get","prefixColor","gray","dim","logCommandEvent","logCommandText","log","logGlobalEvent","write","lines","split","map","line","lastChar","join"],"mappings":"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","sourcesContent":["const chalk = require('chalk');\nconst _ = require('lodash');\nconst formatDate = require('date-fns/format');\n\nconst defaults = require('./defaults');\n\nmodule.exports = class Logger {\n    constructor({ outputStream, prefixFormat, prefixLength, raw, timestampFormat }) {\n        this.raw = raw;\n        this.outputStream = outputStream;\n        this.prefixFormat = prefixFormat;\n        this.prefixLength = prefixLength || defaults.prefixLength;\n        this.timestampFormat = timestampFormat || defaults.timestampFormat;\n    }\n\n    shortenText(text) {\n        if (!text || text.length <= this.prefixLength) {\n            return text;\n        }\n\n        const ellipsis = '..';\n        const prefixLength = this.prefixLength - ellipsis.length;\n        const endLength = Math.floor(prefixLength / 2);\n        const beginningLength = prefixLength - endLength;\n\n        const beginnning = text.substring(0, beginningLength);\n        const end = text.substring(text.length - endLength, text.length);\n        return beginnning + ellipsis + end;\n    }\n\n    getPrefixesFor(command) {\n        return {\n            none: '',\n            pid: command.pid,\n            index: command.index,\n            name: command.name,\n            command: this.shortenText(command.command),\n            time: formatDate(Date.now(), this.timestampFormat)\n        };\n    }\n\n    getPrefix(command) {\n        const prefix = this.prefixFormat || (command.name ? 'name' : 'index');\n        if (prefix === 'none') {\n            return '';\n        }\n\n        const prefixes = this.getPrefixesFor(command);\n        if (Object.keys(prefixes).includes(prefix)) {\n            return `[${prefixes[prefix]}]`;\n        }\n\n        return _.reduce(prefixes, (prev, val, key) => {\n            const keyRegex = new RegExp(_.escapeRegExp(`{${key}}`), 'g');\n            return prev.replace(keyRegex, val);\n        }, prefix).trim();\n    }\n\n    colorText(command, text) {\n        const color = _.get(chalk, command.prefixColor, chalk.gray.dim);\n        return color(text);\n    }\n\n    logCommandEvent(text, command) {\n        if (this.raw) {\n            return;\n        }\n\n        this.logCommandText(chalk.gray.dim(text) + '\\n', command);\n    }\n\n    logCommandText(text, command) {\n        const prefix = this.colorText(command, this.getPrefix(command));\n        return this.log(prefix + (prefix ? ' ' : ''), text);\n    }\n\n    logGlobalEvent(text) {\n        if (this.raw) {\n            return;\n        }\n\n        this.log(chalk.gray.dim('-->') + ' ', chalk.gray.dim(text) + '\\n');\n    }\n\n    log(prefix, text) {\n        if (this.raw) {\n            return this.outputStream.write(text);\n        }\n\n        // #70 - replace some ANSI code that would impact clearing lines\n        text = text.replace(/\\u2026/g, '...');\n\n        const lines = text.split('\\n').map((line, index, lines) => {\n            // First line will write prefix only if we finished the last write with a LF.\n            // Last line won't write prefix because it should be empty.\n            if (index === 0 || index === lines.length - 1) {\n                return line;\n            }\n            return prefix + line;\n        });\n\n        if (!this.lastChar || this.lastChar === '\\n') {\n            this.outputStream.write(prefix);\n        }\n\n        this.lastChar = text[text.length - 1];\n        this.outputStream.write(lines.join('\\n'));\n    }\n};\n"]},"metadata":{},"sourceType":"script"}